# Go desde cero
Curso para aprender Go 
20 Nov 2020
Tags: novato,curso,principiante,aprender
Summary: Desarrollado para un curso de WIE ITBA. 


Patricio Whittingslow
Agustín Canalis
pwhittingslow@itba.edu.ar
acanalis@itba.edu.ar


## Qué es Go?

## 
<script>
let firstArticle = document.getElementsByTagName("article")[0];
firstArticle.innerHTML = firstArticle.innerHTML + '<img src="/assets/go-img/gopher_pencil_megaphone.jpg" style="position:fixed; right:0; bottom:0;  width:50%"/>';
</script>

Lenguaje de programación moderno caracterizado por su simplicidad, manejo de memoria (garbage collection) y buen manejo en equipos grandes.

: Mientras esperaban 40 minutos para que termine de compilar un programa C++, un equipo de 3 personas de Google se pusieron a pensar que forma tendría un lenguaje moderno... 
: No es necesario manejar la memoria en Go, se ocupa solo el lenguaje y te simplifica la vida bastante! Es todo un surtido de bugs que ya no molestan
: Go es usado en Google, Discord, Netflix, Amazon, Twitch. Soluciona problemas para grandes empresas y es ideal para grandes equipos
: debido a esto último se suele pensar que Go solo le sirve a las empresas grandes, no es verdad! Es un lenguaje buenísimo para varias otras cosas!
: Ken Thompson, co-creador de Go, es el creador de C.
: Go toma simplicidad de todos los lenguajes vistos arriba y es lo que se dice que lo destaca entre otros lenguajes complejos como C++ y Java. Comparando lenguajes: Go solo tiene 82 páginas de spec sheet comparado a las 806 de Java (x10) o las 1600+ páginas del estándar ISO de C++

Inspiración para Go

* OOP de **Smalltalk**
* Sintaxis de **Algol**
* _Garbage Collection_ de **Limbo**
* Concurrencia de **Newsqueak**
* Legibilidad y facilidad de uso de **Python**

<img src="/assets/go-img/green-ubuntu-coffee.png" style="position:fixed; right:0; bottom:0;  width:35%"/> 

// Cana: Esto está algo colgado.
// ## Palabras clave
// Hay sólo 25 palabras clave en Go:
// .code src/0keywords.go /KW_S/,/KW_E/
// .caption Una lista completa de todos los _keywords_ de Go

## Hello World

## Hello World {#helloworld}

.play -edit src/1helloworld.go

La línea:

.code src/1helloworld.go /package/

establece que estamos escribiendo un paquete que en este caso se llama main. Luego, la línea: 

.code src/1helloworld.go /import/

indica que vamos a usar cosas de la librería `fmt`. 

##

Lo que en verdad corre de todo esto es:

.play -edit src/1helloworld.go /START/,/END/ HLhello

* Se declara **`s`** de tipo **`string`** y se le asigna el valor **`Hello, 世界`**
* A través de la sintaxis `fmt.Println` seleccionamos la función **`Println`**, que nos deja imprimir cualquier valor a consola.

<details><summary><b>aclaracion nombre de paquetes</b></summary>

Los programas ejecutables siempre tienen <code>"package main"</code> y tienen una función llamada <code>"main()"</code> que no tiene argumentos
como en el ejemplo. 

Los paquetes diseñados para ser importados por otros no tienen esa restricción. Pueden llamarse <code>package pizza</code> si se quiere.
</details>

// Cana: Overflows, and it could be introduced in an example
// <details><summary><b>cómo importar varias librerías</b></summary>
//  Para importar varias librerías se rodean con parentesis
// 
// .code src/1imports.go /import/,/\)/
// </details>

## Variables y Tipos 

## Variables y tipos básicos

Una variable es un identificador que representa un valor. 

En Go, toda variable tiene un tipo, es decir, información adicional acerca de cuales valores pueden ser guardados y cuales no.

Los tipos más usuales son <code>string</code> e <code>int</code>.

<details><summary> lista completa de tipos básicos</summary>

.code src/0types.go /TYPES_S/,/TYPES_E/
</details>

.play -edit src/1helloworldfail.go /MAIN_S/,/MAIN_E/

Aquí <code>s</code> es de tipo <code>string</code> y guarda el valor "Hello World".

Intentar asignarle un valor numérico es un error.

: El compilador **exige** saber siempre de qué tipo es cada variable. Esto permite optimizar espacio de memoria. En python esto no es así

## Diferentes maneras de asignar variables. 

Para declarar una variable **sin** darle un valor, se hace lo siguiente: 

.play -edit src/2shorthand.go /DECL_S/,/DECL_E/

Si uno quiere declarar **y** asignar, las siguientes son equivalentes:  

.play -edit src/2shorthand.go /ASSIGN_S/,/ASSIGN_E/

Estos ahorros son porque no hace falta aclarar que es <code>string</code> si se puede saber por contexto. El <code>:=</code> es una sintaxis más corta para <code>var</code>, pero equivalente.

Luego de que se declara una variable, se puede cambiarle el valor con el <code>=</code>

.play -edit src/2shorthand.go /USE_S/,/USE_E/

.caption Para cualquier variable típica primero se usa <code>:=</code> y a partir de ahí se usa el <code>=</code>.

## 
<h3>Tipo <code> int</code></h3>

Go tiene los siguientes operadores básicos para números enteros: **`+ - * / %`**

.play -edit  src/1numbers.go /MAIN_S/,/MAIN_E/

Se pueden ahorrar algo de tiempo de esta manera:

.play -edit  src/1numberssimple.go /MAIN_S/,/MAIN_E/

Para esta presentación vamos a usar el estilo que normalmente se usa para declarar variables según la situación. 
Más información en la última placa.


: En la práctica, se usa más la versión corta.

: PATO :Acuerdense que todo programa corre adentro de la función main(). De ahora en adelante obviaremos esta parte del código para algunos ejemplos
// CANA: Lo de obviar la función main me parece demasiado implícito, y son dos líneas. Si tenemos sufience espacio, diría de mantener func main(){}
: empieza a parecerse a python el código de a poco

: Cambiar + por -,*,/,% y cambiar int a float64 
// CANA: Consider mentioning if and when we use it: Como es usual, la division entera redondea para abajo

## 
<h3>Tipo <code>string</code></h3>

Se pueden concatenar strings con los operadores **`+`** y **`+=`**

.play -edit src/1arithmeticstring.go /PROG_S/,/PROG_E/

: Introducir operador += !

## Expresiones: if, for, y func

## 
<h3><code>if</code></h3>

Ejecuta un bloque de código si se cumple una condición.  

.play -edit src/3ifelse.go /PROG_S/,/PROG_E/

El bloque delimitado por <code>{}</code> se ejecuta sólamente si <code>a</code> es igual a <code>pizza</code>. 

<details><summary>Valores de tipo <code>bool</code></summary>
La expresión <code>a=="pizza"</code> es un valor de tipo <code>bool</code>, y puede tener el valor de <code>true</code> o <code>false</code>. 

Como tal, se puede guardar en una variable, de esta manera: 

<code>var b bool = a=="pizza"</code>
 </details>

<details><summary>Otros operadores</summary>

.code src/3ifops.txt
</details>

<details><summary>sintaxis de else y else-if</summary>

.play -edit src/3elseif.go /PROG_S/,/PROG_E/
</details>

## 
<h3><code>for</code></h3>

Ejecuta un bloque de código una y otra vez mientras la condición sea verdadera.
La sintaxis incluye la posibilidad de inicializar variables antes de empezar, y también de modificar variables cada vez que se termina de ejecutar el bloque.

.play -edit src/3fori.go /PROG_S/,/PROG_E/

Aquí se inicializa <code>i</code>, se verifica que <code>i<10</code>, y se corre el bloque, que ente caso simplemente imprime <code>i</code>. Luego, se le suma 1 y se verifica la condición nuevamente. 

: Problema: aparece mucho syntax sugar de una aca y todavia no lo vimos anteriormente

// Un for que recorre un arreglo
//.play -edit src/3forrange.go /PROG_S/,/PROG_E/

## 
<h3><code>func</code></h3>

Una función es una parte de código que queremos reutilizar. Un ejemplo clásico es una función que devuelve la suma de dos números

.code  src/2func.go /PROG_S/,/PROG_E/

: en este ejemplo trivial x e y son los inputs y la salida es la suma de los dos

Ahora en cualquier lugar de nuestro código que queramos sumar dos números, podemos hacerlo de esta manera: 

.play -edit src/2func.go /FUNC_S/,/FUNC_E/

.caption Las funciones se pueden asignar a variables y ser argumentos de otras funciones.

: Se dieron cuenta que asigne con los dos puntos? El siguiente slide veremos las varias formas 
: Que quede claro donde defino las funciones. son por afuera de main... aunque no hay nada que me impida de definirla adentro
// CANA: Consider skipping, unless we use it in the future

## Retorno de múltiples valores

.play -edit src/2multireturn.go 

// Conside skipping, unless used

## 
<h3> Bloques <code>{ }</code> y Scope (alcance) </h3>

.play -edit src/1blocks.go /MAIN_S/,/MAIN_E/

Hay una tres reglas muy simples que indican si se puede acceder a una variable en un cierto lugar o no:

1. El caracter <code>{</code> abre un bloque y <code>}</code> lo cierra. 

2. En una función, una variable se puede utilizar desde que se declara, hasta que cierra el bloque que la contiene.

3. Una variable declara fuera de la función (en el top level) siempre es accesible, independientemente del orden.


## Últimos comentarios

## Charla dada por el product manager de Go (2015)
: CANA: Add other resources.

Un video que todo gopher debería ver. Se trata sobre el origen de Go.

.iframe https://www.youtube.com/embed/sX8r6zATHGU 500 800

## Preguntas? 

.image /assets/go-img/purple-pacman-nerd.png 480 _
.caption Diseño del _Gopher_ hecho por [[https://instagram.com/reneefrench][Renee French]]. Crédito a Mat Ryer por la WebApp [[https://gopherize.me/][Gopherize me]]

