# Go efectivo
20 Nov 2020
Tags: curso,avanzado,efectivo
Summary: Desarrollado para un curso de WIE ITBA.
OldURL: https://a/


Patricio Whittingslow
Agustín Canalis
pwhittingslow@itba.edu.ar
acanalis@itba.edu.ar

## ¿Por que Go?

* Go está diseñado para ingeniería informática moderna
* Go es simple
* Go es rápido
* Escribir programas concurrentes es fácil
* El ecosistema Go
* [Más info](https://stackoverflow.blog/2020/11/02/go-golang-learn-fast-programming-languages/)

: Go hace todo lo que hacen los lenguajes de programación comunes
: El ecosistema Go se refiere a la interacción entre los desarrolladores y el equipo Go. Hay un dialogo activo con mucha ida y vuelta. La comunidad esta sumamente involucrada en los cambios de Go, como veran el los git issues.

## Casos de uso

* Web development
    * Librerías: [`http`](https://golang.org/pkg/net/http/), [`pion`](https://github.com/pion/webrtc#readme) (webrtc) y [`gorilla`](https://github.com/gorilla/)
    * Framework. [`gin`](https://github.com/gin-gonic) y [`buffalo`](https://gobuffalo.io/en/)

* Programas CLI
    * Librerías: [`pflags`](https://github.com/spf13/pflag#readme), [`termbox`](https://github.com/nsf/termbox-go#readme)
    * Frameworks: [`cobra`](https://github.com/spf13/cobra#readme)


* [Cientos de otras cosas](https://github.com/avelino/awesome-go#awesome-go)

: Antes de empezar con un framework se recomienda FUERTEMENTE aprender los patterns de Go bien. Después se te va complicar como hacer ciertas cosas y la vas a pasar mal sin conocimiento profundo previo de Go.

: Muy recomendado buffalo para programar un sitio completo frontend-backend. Tiene bootstrap integrado con posibilidad de integrar Vue.js. Postgres, mysql, sqlite3, etc para DB. Muy inspirado en ruby, los que vengan de Ruby on rails estarán muy afamiliarizados con el flujo de desarrollo.


## Hello World

## Hello World

.play -edit src/1helloworld.go /package/,/MAIN_E/

El primer argumento de Printf es un string con el formato que queremos que imprima el resto de los argumentos. 
El %v indica que queremos que se inserte el siguiente argumento con formato de string, y en ese lugar. 

<details><summary> Lista completa de verbos </summary>

.code src/1helloworld.go /FMT_S/,/FMT_E/

</details>

## Tipos compuestos

## Tipos compuestos

Un tipo compuesto es un tipo de dato que puede ser construido con los tipos primitivos de un lenguaje.

* Slices (listas/vector)
* Structs 
* Maps (dicts)
* Interfaces

.image /assets/go-img/gopher.png 200 _
.caption Diseño del _Gopher_ hecho por [[https://instagram.com/reneefrench][Renee French]]

## Slices

Un slice es un conjunto de datos del mismo tipo, ordenados secuencialmente. 

.play -edit src/1slice.go /PROG_S/,/PROG_E/

// Cana: consider skipping: 
: Existe una representación de más bajo nivel que rara vez se usa, llamada arreglo. Tiene longitud fija, y las copias son independientes entre sí.

: La declaración corta ahorra mucho espacio y hace que el código sea más legible pero puede resultar confuso! Ver esta guía para entender las diferencias. Vamos a alternar entre formas de declarar para que se vayan acostumbrando a Go. Puede llevar un tiempo acostumbrarse a las varias formas de declarar variables

## Structs

Un struct es una colección de campos. Un campo es una variable que tiene un determinado nombre y un determinado tipo.

.play -edit src/3structdeclaration.go /type Pel/,/MAIN_E/

## Maps (diccionarios)

Un mapa es una relación entre valores de un tipo y valores de otro. 

.play -edit src/1maps.go /PROG_S/,/PROG_E/

## Métodos 

## Metodos: Declaración y uso

Un método es una función que está ligada a un cierto tipo. 

.play -edit src/4method.go /type/,/MAIN_E/

## Pasando referencias

Las funciones (y métodos) reciben copias de los argumentos, no los argumentos en sí. Por eso, modificarlos adentro de una función no tiene ningún efecto. (Ver ejemplo sin asterisco)

Si eso es lo que buscamos, hay que pasar **referencias** como argumentos, es decir, punteros. 

.play -edit src/4methodref.go /REFMETHOD_S/,/MAIN_E/
.caption Probar el código con y sin el asterisco en el receptor para ver la diferencia. Si sabés que son los punteros esto no es nada nuevo. Si no, no pasa nada, no los usaremos.

## Bloques y Funciones

## 
<h3> Bloques <code>{ }</code> y Scope (alcance) </h3>

.play -edit src/1blocks.go /MAIN_S/,/MAIN_E/

Hay una tres reglas muy simples que indican si se puede acceder a una variable en un cierto lugar o no:

1. El caracter <code>{</code> abre un bloque y <code>}</code> lo cierra. 

2. En una función, una variable se puede utilizar desde que se declara, hasta que cierra el bloque que la contiene.

3. Una variable declara fuera de la función (en el top level) siempre es accesible, independientemente del orden.

## Funciones como valores

Las funciones pueden ser guardadas en una variable. En el siguinte ejemplo se asigna y declara
la variable <code>mas1</code>:

.play -edit src/2inlinefunc.go /PROG_S/,/PROG_E/

Aquí se declara, llama, y devuelve inmediatamente la función

.play -edit src/2inlinereturn.go /PROG_S/,/PROG_E/


## Closures (ejemplo)

Una patrón común que usa esto se denomina _closure_ y se usa cuando se quiere que la función acceda a variables definidas por fuera de ésta. En el siguiente ejemplo <code>mas1</code> puede acceder a la variable <code>a</code> definida anteriormente.

.play -edit src/2closure.go /PROG_S/,/PROG_E/
El concepto de un _closure_ es especialmente útil cuando entran en juego los modificadores de funciones, <code>defer</code> y <code>go</code>.

: Las funciones son first class citizens en Go. Se pueden usar como variables. Hay veces que tiene sentido pasar una función pero en general el OOP se encarga mejor de eso.
: Los dos ejemplos de arriba son casi idénticos. El compilador de Go usa function inlining por defecto, no asigna un bloque de memoria para cada función
: Este ejemplo es testamento a la inutilidad de closures en un lenguaje común. Se imaginan que concepto de Go las puede hacer útiles?
: Las function modifiers: `go` y `defer`



## Funciones variadicas

.code src/2variadic.go /FUNC_S/,/FUNC_E/

.play -edit src/2variadic.go /PROG_S/,/PROG_E/
.caption Una función puede tomar un número indefinido de argumentos pero la cantidad a devolver es fija 

## Interfaces

## Interfaces

Una interface es una colección de métodos. 

Así se define una de las interfaces más importantes, la <code>io.Reader</code>

.code src/5interface.go /INTERFACE_S/,/INTERFACE_E/

Un tipo interface representa a **cualquier** tipo que tenga implementado ese método con ese nombre y esos argumentos. 

Una función que tome a un tipo interface como argumento es, en efecto, una función que acepta a cualquiera de esos tipos.

## Ejemplo 1

En el paquete <code>ioutil</code> hay una función llamada <code>ReadAll</code>, que lee todos los contenidos de un <code>io.Reader</code>.

.code src/5interface.go /READALL_S/,/READALL_E/

En la librería estándar hay 31 tipos que cumplen las condiciones del <code>io.Reader</code>:

.code src/5interface.txt

Uno puede llamar a <code>ReadAll</code> con cualquiera de ellos, y la función hace su trabajo sin tener en cuenta si lo que le enviaron un buffer, una respuesta http, un archivo, o lo que sea. 

## Ejemplo 2

.play src/5interface.go /ALL_S/,/ALL_E/

## ¿Por qué interfaces?

Es una abstracción que toma en cuenta la ***funcionalidad*** común entre tipos de datos.

No tienen mucho uso cuando uno programa en soledad. Se convierten en un abstracción fundamental al programar cuando muchas librerías implementan la interface. 

Con interfaces:
* La programadora de funciones puede abstraer detalles y dar flexibilidad a las usuarias.
* La usuaria de las funciones tiene un amplio catálogo de funciones disponibles.

## Concurrencia

## Un programa secuencial (no concurrente)

.play src/6nonconcurrentcounter.go

## 
<h3> Concurrencia y <code>go</code> </h3>

La concurrencia es la ejecución de procesos al mismo tiempo.

En go, esto se logra usando la palabra <code>go</code> antes de las funciones. 

.code src/6concurrentcounterpitfall.go /GOLINE_S/,/GOLINE_E/

<code>go</code> ejecuta la función, mientras que el programa continúa inmediatamente sin esperar a que la función termine.

Se llaman **gorutinas** a cada uno de estos procesos independientes.

: las gorutinas son super livianas y no es raro tener miles o ciento de miles corriendo a la vez. 

Cualquier función puede ser llamada con <code>go</code> sin necesidad de modificarla.

: No hay que moficar la función, A diferencia de otros lenguajes como Javascript y Python

<figcaption style="position: absolute; bottom:40px;"> "Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once." ~ <a href="https://www.youtube.com/watch?v=oV9rvDllKEg"> Rob Pike</a></figcaption>

## Un programa concurrente

.play -edit src/6concurrentcounterpitfall.go
<figcaption>Modificar la línea de <code>main()</code> a <code>go Hacer("pan🍞")</code></figcaption>

## Intentando sincronizar gorutinas

.play -edit src/6concurrentcounter.go /MAIN_S/,/MAIN_E/
.caption Si bien el `bool` sirve para sincronizar gorutinas ahora veremos formas más flexibles y poderosas de comunicar *y* sincronizar

## Canales (channels)

## Canales

Los canales se usan para mandar mensajes entre gorutinas. 

Para inicializar un canal:

.code src/6channels.go  /CHANMAKE_S/,/CHANMAKE_E/

Para enviar un mensaje:

.code src/6channels.go  /CHANSEND_S/,/CHANSEND_E/

Para recibir un mensaje: 

.code src/6channels.go  /CHANREC_S/,/CHANREC_E/

<figcaption> En este caso los mensajes son de tipo <code>string</code>, pero puede usarse cualquier tipo</figcaption>

## Ejemplo 

.play src/6gopizza.go /MAIN_S/,/FUNC_E/

.caption Los canales comunican *y* sincronizan. Dos conceptos muy importantes en Go.

: Se pueden asignar a variables y pasarse como argumentos a funciones y tienen un tipo asignado.
: Se parecen más a file descriptors

## Sincronizando con canales (intento 1) 
// Contador con canales

.play -edit src/6chancounter.go /MAIN_S/,/FUNC_E/

<code>Hacer</code> se bloquea porque nadie recibe su segundo mensaje. 

Esto es porque los canales son bloquean la gorutina hasta que el mensaje es efectivamente recibido o enviado. 

.caption más información más adelante

## Sincronizando con canales (intento 2) 

.play -edit src/6chandeadlock.go

## All goroutines are asleep - deadlock! - Explicación

La función <code>Contar</code> termina luego de 5 mensajes. Mientras tanto <code>main</code> se queda esperando un sexto mensaje que nunca llegará! El programa se da cuenta cuando hay un canal bloqueado infinitamente y termina con el error ***deadlock!***.

Para prevenir este error, se puede **cerrar** un canal de esta manera:

.code src/6chanclose.go /CLOSE_S/,/CLOSE_E/

Y las gorutinas que reciben mensajes de ese canal pueden preguntar si sigue abierto o no: 

.code src/6chanclose.go /ASK_S/,/ASK_E/

El segundo argumento (<code>abierto</code>) es un <code>bool</code> que vale <code>true</code> si el canal está abierto.

## Sincronizando con canales (intento 3)

.play -edit src/6chanclose.go /MAIN_S/,/FUNC_E/
.caption Una vez cerrado el canal el valor de abierto será falso y sabremos que se ha dejado de enviar mensajes por el canal. OJO! Si se manda un mensaje por un canal cerrado el programa termina con error!

## Más elegante: Range canal

Este código es equivalente, pero más corto.

.play -edit src/6chanrange.go /MAIN_S/,/FUNC_E/
.caption La palabra clave `range` se puede usar para iterar sobre canales, slices y mapas

## Bloqueo de canales

* Una gorutina que necesita un mensaje de un canal, y no lo encuentra, se bloquea.
* Una gorutina que envía un mensaje por un canal, y éste no es recibido por otra se bloquea. 

Mandar por un canal no se compara a un tiro de basketball. Es más parecido a una entrega de pizza. La mensajera se queda esperando en la puerta a ser atendida.

.play -edit src/6chanbuffpitfall.go /MAIN_S/,/MAIN_E/

En este caso la mensajera bloquea el programa y el receptor nunca llega a atenderlo, causando un ***deadlock***.

.caption esto se resuelve con buffered channels

## Buffered channels 

Un buffered channel es un canal que puede guardar un cierto número de mensajes antes de bloquearse. 

.play -edit src/6chanbuff.go /MAIN_S/,/MAIN_E/

Ahora puede seguir la ejecución después de mandar un mensaje. El tamaño del buffer puede ser cualquiera.

## Select

## Bloqueo de canales lentos

El siguiente programa es limitado por la gorutina más lenta. 0.5 vs. 2 segundos

.play -edit src/6beforeselect.go /MAIN_S/,/MAIN_E/
.caption El programa es limitado por la velocidad a la que el canal 2 puede recibir mensajes (`<-c2`)

## Select

La palabra clave select le permite al programa esperar hasta que haya un canal con un mensaje entre varios canales.

.play -edit src/6afterselect.go /MAIN_S/,/MAIN_E/

## Paquete os, manejo de errores y lectura de archivos

.play -edit src/5os.go

## Preguntas?