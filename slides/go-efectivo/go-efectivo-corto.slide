# Go efectivo
20 Nov 2020
Tags: curso,avanzado,efectivo
Summary: Desarrollado para un curso de WIE ITBA.
OldURL: https://a/


Patricio Whittingslow
Agust칤n Canalis
pwhittingslow@itba.edu.ar
acanalis@itba.edu.ar

## 쯇or que Go?

* Go est치 dise침ado para ingenier칤a inform치tica moderna
* Go es simple
* Go es r치pido
* Escribir programas concurrentes es f치cil
* El ecosistema Go
* [M치s info](https://stackoverflow.blog/2020/11/02/go-golang-learn-fast-programming-languages/)

: Go hace todo lo que hacen los lenguajes de programaci칩n comunes
: El ecosistema Go se refiere a la interacci칩n entre los desarrolladores y el equipo Go. Hay un dialogo activo con mucha ida y vuelta. La comunidad esta sumamente involucrada en los cambios de Go, como veran el los git issues.

## Casos de uso

* Web development
    * Librer칤as: [`http`](https://golang.org/pkg/net/http/), [`pion`](https://github.com/pion/webrtc#readme) (webrtc) y [`gorilla`](https://github.com/gorilla/)
    * Framework. [`gin`](https://github.com/gin-gonic) y [`buffalo`](https://gobuffalo.io/en/)

* Programas CLI
    * Librer칤as: [`pflags`](https://github.com/spf13/pflag#readme), [`termbox`](https://github.com/nsf/termbox-go#readme)
    * Frameworks: [`cobra`](https://github.com/spf13/cobra#readme)


* [Cientos de otras cosas](https://github.com/avelino/awesome-go#awesome-go)

: Antes de empezar con un framework se recomienda FUERTEMENTE aprender los patterns de Go bien. Despu칠s se te va complicar como hacer ciertas cosas y la vas a pasar mal sin conocimiento profundo previo de Go.

: Muy recomendado buffalo para programar un sitio completo frontend-backend. Tiene bootstrap integrado con posibilidad de integrar Vue.js. Postgres, mysql, sqlite3, etc para DB. Muy inspirado en ruby, los que vengan de Ruby on rails estar치n muy afamiliarizados con el flujo de desarrollo.


## Hello World

## Hello World

.play -edit src/1helloworld.go /package/,/MAIN_E/

El primer argumento de Printf es un string con el formato que queremos que imprima el resto de los argumentos. 
El %v indica que queremos que se inserte el siguiente argumento con formato de string, y en ese lugar. 

<details><summary> Lista completa de verbos </summary>

.code src/1helloworld.go /FMT_S/,/FMT_E/

</details>

## Tipos compuestos

## Tipos compuestos

Un tipo compuesto es un tipo de dato que puede ser construido con los tipos primitivos de un lenguaje.

* Slices (listas/vector)
* Structs 
* Maps (dicts)
* Interfaces

.image /assets/go-img/gopher.png 200 _
.caption Dise침o del _Gopher_ hecho por [[https://instagram.com/reneefrench][Renee French]]

## Slices

Un slice es un conjunto de datos del mismo tipo, ordenados secuencialmente. 

.play -edit src/1slice.go /PROG_S/,/PROG_E/

// Cana: consider skipping: 
: Existe una representaci칩n de m치s bajo nivel que rara vez se usa, llamada arreglo. Tiene longitud fija, y las copias son independientes entre s칤.

: La declaraci칩n corta ahorra mucho espacio y hace que el c칩digo sea m치s legible pero puede resultar confuso! Ver esta gu칤a para entender las diferencias. Vamos a alternar entre formas de declarar para que se vayan acostumbrando a Go. Puede llevar un tiempo acostumbrarse a las varias formas de declarar variables

## Structs

Un struct es una colecci칩n de campos. Un campo es una variable que tiene un determinado nombre y un determinado tipo.

.play -edit src/3structdeclaration.go /type Pel/,/MAIN_E/

## Maps (diccionarios)

Un mapa es una relaci칩n entre valores de un tipo y valores de otro. 

.play -edit src/1maps.go /PROG_S/,/PROG_E/

## M칠todos 

## Metodos: Declaraci칩n y uso

Un m칠todo es una funci칩n que est치 ligada a un cierto tipo. 

.play -edit src/4method.go /type/,/MAIN_E/

## Pasando referencias

Las funciones (y m칠todos) reciben copias de los argumentos, no los argumentos en s칤. Por eso, modificarlos adentro de una funci칩n no tiene ning칰n efecto. (Ver ejemplo sin asterisco)

Si eso es lo que buscamos, hay que pasar **referencias** como argumentos, es decir, punteros. 

.play -edit src/4methodref.go /REFMETHOD_S/,/MAIN_E/
.caption Probar el c칩digo con y sin el asterisco en el receptor para ver la diferencia. Si sab칠s que son los punteros esto no es nada nuevo. Si no, no pasa nada, no los usaremos.

## Bloques y Funciones

## 
<h3> Bloques <code>{ }</code> y Scope (alcance) </h3>

.play -edit src/1blocks.go /MAIN_S/,/MAIN_E/

Hay una tres reglas muy simples que indican si se puede acceder a una variable en un cierto lugar o no:

1. El caracter <code>{</code> abre un bloque y <code>}</code> lo cierra. 

2. En una funci칩n, una variable se puede utilizar desde que se declara, hasta que cierra el bloque que la contiene.

3. Una variable declara fuera de la funci칩n (en el top level) siempre es accesible, independientemente del orden.

## Funciones como valores

Las funciones pueden ser guardadas en una variable. En el siguinte ejemplo se asigna y declara
la variable <code>mas1</code>:

.play -edit src/2inlinefunc.go /PROG_S/,/PROG_E/

Aqu칤 se declara, llama, y devuelve inmediatamente la funci칩n

.play -edit src/2inlinereturn.go /PROG_S/,/PROG_E/


## Closures (ejemplo)

Una patr칩n com칰n que usa esto se denomina _closure_ y se usa cuando se quiere que la funci칩n acceda a variables definidas por fuera de 칠sta. En el siguiente ejemplo <code>mas1</code> puede acceder a la variable <code>a</code> definida anteriormente.

.play -edit src/2closure.go /PROG_S/,/PROG_E/
El concepto de un _closure_ es especialmente 칰til cuando entran en juego los modificadores de funciones, <code>defer</code> y <code>go</code>.

: Las funciones son first class citizens en Go. Se pueden usar como variables. Hay veces que tiene sentido pasar una funci칩n pero en general el OOP se encarga mejor de eso.
: Los dos ejemplos de arriba son casi id칠nticos. El compilador de Go usa function inlining por defecto, no asigna un bloque de memoria para cada funci칩n
: Este ejemplo es testamento a la inutilidad de closures en un lenguaje com칰n. Se imaginan que concepto de Go las puede hacer 칰tiles?
: Las function modifiers: `go` y `defer`



## Funciones variadicas

.code src/2variadic.go /FUNC_S/,/FUNC_E/

.play -edit src/2variadic.go /PROG_S/,/PROG_E/
.caption Una funci칩n puede tomar un n칰mero indefinido de argumentos pero la cantidad a devolver es fija 

## Interfaces

## Interfaces

Una interface es una colecci칩n de m칠todos. 

As칤 se define una de las interfaces m치s importantes, la <code>io.Reader</code>

.code src/5interface.go /INTERFACE_S/,/INTERFACE_E/

Un tipo interface representa a **cualquier** tipo que tenga implementado ese m칠todo con ese nombre y esos argumentos. 

Una funci칩n que tome a un tipo interface como argumento es, en efecto, una funci칩n que acepta a cualquiera de esos tipos.

## Ejemplo 1

En el paquete <code>ioutil</code> hay una funci칩n llamada <code>ReadAll</code>, que lee todos los contenidos de un <code>io.Reader</code>.

.code src/5interface.go /READALL_S/,/READALL_E/

En la librer칤a est치ndar hay 31 tipos que cumplen las condiciones del <code>io.Reader</code>:

.code src/5interface.txt

Uno puede llamar a <code>ReadAll</code> con cualquiera de ellos, y la funci칩n hace su trabajo sin tener en cuenta si lo que le enviaron un buffer, una respuesta http, un archivo, o lo que sea. 

## Ejemplo 2

.play src/5interface.go /ALL_S/,/ALL_E/

## 쯇or qu칠 interfaces?

Es una abstracci칩n que toma en cuenta la ***funcionalidad*** com칰n entre tipos de datos.

No tienen mucho uso cuando uno programa en soledad. Se convierten en un abstracci칩n fundamental al programar cuando muchas librer칤as implementan la interface. 

Con interfaces:
* La programadora de funciones puede abstraer detalles y dar flexibilidad a las usuarias.
* La usuaria de las funciones tiene un amplio cat치logo de funciones disponibles.

## Concurrencia

## Un programa secuencial (no concurrente)

.play src/6nonconcurrentcounter.go

## 
<h3> Concurrencia y <code>go</code> </h3>

La concurrencia es la ejecuci칩n de procesos al mismo tiempo.

En go, esto se logra usando la palabra <code>go</code> antes de las funciones. 

.code src/6concurrentcounterpitfall.go /GOLINE_S/,/GOLINE_E/

<code>go</code> ejecuta la funci칩n, mientras que el programa contin칰a inmediatamente sin esperar a que la funci칩n termine.

Se llaman **gorutinas** a cada uno de estos procesos independientes.

: las gorutinas son super livianas y no es raro tener miles o ciento de miles corriendo a la vez. 

Cualquier funci칩n puede ser llamada con <code>go</code> sin necesidad de modificarla.

: No hay que moficar la funci칩n, A diferencia de otros lenguajes como Javascript y Python

<figcaption style="position: absolute; bottom:40px;"> "Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once." ~ <a href="https://www.youtube.com/watch?v=oV9rvDllKEg"> Rob Pike</a></figcaption>

## Un programa concurrente

.play -edit src/6concurrentcounterpitfall.go
<figcaption>Modificar la l칤nea de <code>main()</code> a <code>go Hacer("pan游")</code></figcaption>

## Intentando sincronizar gorutinas

.play -edit src/6concurrentcounter.go /MAIN_S/,/MAIN_E/
.caption Si bien el `bool` sirve para sincronizar gorutinas ahora veremos formas m치s flexibles y poderosas de comunicar *y* sincronizar

## Canales (channels)

## Canales

Los canales se usan para mandar mensajes entre gorutinas. 

Para inicializar un canal:

.code src/6channels.go  /CHANMAKE_S/,/CHANMAKE_E/

Para enviar un mensaje:

.code src/6channels.go  /CHANSEND_S/,/CHANSEND_E/

Para recibir un mensaje: 

.code src/6channels.go  /CHANREC_S/,/CHANREC_E/

<figcaption> En este caso los mensajes son de tipo <code>string</code>, pero puede usarse cualquier tipo</figcaption>

## Ejemplo 

.play src/6gopizza.go /MAIN_S/,/FUNC_E/

.caption Los canales comunican *y* sincronizan. Dos conceptos muy importantes en Go.

: Se pueden asignar a variables y pasarse como argumentos a funciones y tienen un tipo asignado.
: Se parecen m치s a file descriptors

## Sincronizando con canales (intento 1) 
// Contador con canales

.play -edit src/6chancounter.go /MAIN_S/,/FUNC_E/

<code>Hacer</code> se bloquea porque nadie recibe su segundo mensaje. 

Esto es porque los canales son bloquean la gorutina hasta que el mensaje es efectivamente recibido o enviado. 

.caption m치s informaci칩n m치s adelante

## Sincronizando con canales (intento 2) 

.play -edit src/6chandeadlock.go

## All goroutines are asleep - deadlock! - Explicaci칩n

La funci칩n <code>Contar</code> termina luego de 5 mensajes. Mientras tanto <code>main</code> se queda esperando un sexto mensaje que nunca llegar치! El programa se da cuenta cuando hay un canal bloqueado infinitamente y termina con el error ***deadlock!***.

Para prevenir este error, se puede **cerrar** un canal de esta manera:

.code src/6chanclose.go /CLOSE_S/,/CLOSE_E/

Y las gorutinas que reciben mensajes de ese canal pueden preguntar si sigue abierto o no: 

.code src/6chanclose.go /ASK_S/,/ASK_E/

El segundo argumento (<code>abierto</code>) es un <code>bool</code> que vale <code>true</code> si el canal est치 abierto.

## Sincronizando con canales (intento 3)

.play -edit src/6chanclose.go /MAIN_S/,/FUNC_E/
.caption Una vez cerrado el canal el valor de abierto ser치 falso y sabremos que se ha dejado de enviar mensajes por el canal. OJO! Si se manda un mensaje por un canal cerrado el programa termina con error!

## M치s elegante: Range canal

Este c칩digo es equivalente, pero m치s corto.

.play -edit src/6chanrange.go /MAIN_S/,/FUNC_E/
.caption La palabra clave `range` se puede usar para iterar sobre canales, slices y mapas

## Bloqueo de canales

* Una gorutina que necesita un mensaje de un canal, y no lo encuentra, se bloquea.
* Una gorutina que env칤a un mensaje por un canal, y 칠ste no es recibido por otra se bloquea. 

Mandar por un canal no se compara a un tiro de basketball. Es m치s parecido a una entrega de pizza. La mensajera se queda esperando en la puerta a ser atendida.

.play -edit src/6chanbuffpitfall.go /MAIN_S/,/MAIN_E/

En este caso la mensajera bloquea el programa y el receptor nunca llega a atenderlo, causando un ***deadlock***.

.caption esto se resuelve con buffered channels

## Buffered channels 

Un buffered channel es un canal que puede guardar un cierto n칰mero de mensajes antes de bloquearse. 

.play -edit src/6chanbuff.go /MAIN_S/,/MAIN_E/

Ahora puede seguir la ejecuci칩n despu칠s de mandar un mensaje. El tama침o del buffer puede ser cualquiera.

## Select

## Bloqueo de canales lentos

El siguiente programa es limitado por la gorutina m치s lenta. 0.5 vs. 2 segundos

.play -edit src/6beforeselect.go /MAIN_S/,/MAIN_E/
.caption El programa es limitado por la velocidad a la que el canal 2 puede recibir mensajes (`<-c2`)

## Select

La palabra clave select le permite al programa esperar hasta que haya un canal con un mensaje entre varios canales.

.play -edit src/6afterselect.go /MAIN_S/,/MAIN_E/

## Paquete os, manejo de errores y lectura de archivos

.play -edit src/5os.go

## Preguntas?