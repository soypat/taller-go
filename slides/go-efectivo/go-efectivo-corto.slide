# Go efectivo
20 Nov 2020
Tags: curso,avanzado,efectivo
Summary: Desarrollado para un curso de WIE ITBA.
OldURL: https://a/


Patricio Whittingslow
Agustín Canalis
pwhittingslow@itba.edu.ar
acanalis@itba.edu.ar

## ¿Por que Go?

Tomado de un [StackOverflow blogpost](https://stackoverflow.blog/2020/11/02/go-golang-learn-fast-programming-languages/)


* Go está diseñado para ingeniería informática moderna
* Go es simple
* Go es rápido
* Escribir programas concurrentes es fácil
* El ecosistema Go

: Go hace todo lo que hacen los lenguajes de programación comunes
: El ecosistema Go se refiere a la interacción entre los desarrolladores y el equipo Go. Hay un dialogo activo con mucha ida y vuelta. La comunidad esta sumamente involucrada en los cambios de Go, como veran el los git issues.

## Casos de uso

* Web development
    * Librerías: [`http`](https://golang.org/pkg/net/http/), [`pion`](https://github.com/pion/webrtc#readme) (webrtc) y [`gorilla`](https://github.com/gorilla/)
    * Framework. [`gin`](https://github.com/gin-gonic) y [`buffalo`](https://gobuffalo.io/en/)

* Programas CLI
    * Librerías: [`pflags`](https://github.com/spf13/pflag#readme), [`termbox`](https://github.com/nsf/termbox-go#readme)
    * Frameworks: [`cobra`](https://github.com/spf13/cobra#readme)


* [Cientos de otras cosas](https://github.com/avelino/awesome-go#awesome-go)

: Antes de empezar con un framework se recomienda FUERTEMENTE aprender los patterns de Go bien. Después se te va complicar como hacer ciertas cosas y la vas a pasar mal sin conocimiento profundo previo de Go.

: Muy recomendado buffalo para programar un sitio completo frontend-backend. Tiene bootstrap integrado con posibilidad de integrar Vue.js. Postgres, mysql, sqlite3, etc para DB. Muy inspirado en ruby, los que vengan de Ruby on rails estarán muy afamiliarizados con el flujo de desarrollo.


## Hello World

## Hello World

.play -edit src/1helloworld.go /package/,/MAIN_E/

El primer argumento de Printf es un string con el formato que queremos que imprima el resto de los argumentos. 

El %v indica que queremos que se inserte el siguiente argumento con formato de string, y en ese lugar. 

<details><summary> Lista completa de verbos </summary>

.code src/1helloworld.go /FMT_S/,/FMT_E/

[[https://golang.org/pkg/fmt/][Más información]]
</details>

## Conceptos de Go

## 
<h3> Bloques <code>{ }</code> y Scope (alcance) </h3>

.play -edit src/1blocks.go /MAIN_S/,/MAIN_E/

Hay una tres reglas muy simples que indican si se puede acceder a una variable en un cierto lugar o no:

1. El caracter <code>{</code> abre un bloque y <code>}</code> lo cierra. 

2. En una función, una variable se puede utilizar desde que se declara, hasta que cierra el bloque que la contiene.

3. Una variable declara fuera de la función (en el top level) siempre es accesible, independientemente del orden.

## Tipos compuestos

## Tipos compuestos

Un tipo compuesto es un tipo de dato que puede ser construido con los tipos primitivos de un lenguaje.

* Slices (listas/vector)
* Structs 
* Maps (dicts)
* Interfaces

.image /assets/go-img/gopher.png 200 _
.caption Diseño del _Gopher_ hecho por [[https://instagram.com/reneefrench][Renee French]]

## Slices

Un slice es un conjunto de datos del mismo tipo, ordenados secuencialmente. 

.play -edit src/1slice.go /PROG_S/,/PROG_E/

// Cana: consider skipping: 
: Existe una representación de más bajo nivel que rara vez se usa, llamada arreglo. Tiene longitud fija, y las copias son independientes entre sí.

: La declaración corta ahorra mucho espacio y hace que el código sea más legible pero puede resultar confuso! Ver esta guía para entender las diferencias. Vamos a alternar entre formas de declarar para que se vayan acostumbrando a Go. Puede llevar un tiempo acostumbrarse a las varias formas de declarar variables

## Structs

Un struct es una colección de campos. Un campo es una variable que tiene un determinado nombre y un determinado tipo.

.play -edit src/3structdeclaration.go /type Pel/,/MAIN_E/

## Maps (diccionarios)

Un mapa es una relación entre valores de un tipo y valores de otro. 

.play -edit src/1maps.go /PROG_S/,/PROG_E/

## Métodos 

## Metodos: Declaración y uso

Un método es una función que está ligada a un cierto tipo. 

.play -edit src/4method.go /type/,/MAIN_E/

## Pasando referencias

Las funciones (y métodos) reciben copias de los argumentos, no los argumentos en sí. Por eso, modificarlos adentro de una función no tiene ningún efecto. (Ver ejemplo sin asterisco)

Si eso es lo que buscamos, hay que pasar **referencias** como argumentos, es decir, punteros. 

.play -edit src/4methodref.go /REFMETHOD_S/,/MAIN_E/
.caption Probar el código con y sin el asterisco en el receptor para ver la diferencia. Si sabés que son los punteros esto no es nada nuevo. Si no, no pasa nada, no los usaremos.

## Interfaces

## Interfaces

Una interface es una colección de métodos. Se puede pasar a una función para indicar que ese argumento puede ser cualquier tipo que tenga esos métodos.

.code src/5interface.go /SORTER_S/,/SORTER_E/

La libería <code>sort</code> define esta interface, la cual se usa para la función <code>Sort()</code>.

.code src/5interface.go  /SORTSIGNATURE_S/,/SORTSIGNATURE_E/

<figcaption style="position:absolute;bottom:1.6em;padding-right:4rem; ">"When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck" -<b>James Whitcomb Riley, 1888</b></figcaption> 


## Ejemplo de uso de sort

.play -edit src/5interface.go /USG_S/,/USG_E/
.caption Como `Names` implementa los métodos necesarios, se dice que "Implementa" `sort.Interface`.


: Vamos a declarar un tipo Writer que va ser un interface... Y eso se declara pasando los metodos que implementa
: Es raro al comienzo. Venimos declarando tipos en base a la informacion que tienen y ahora estamos considerando el comportamiento
: Sigue la logica del poeta ingles James Whitcomb Riley: 


## Por qué interfaces?

Es una abstracción que toma en cuenta la ***funcionalidad*** común entre tipos de datos.

No tienen mucho uso cuando uno programa en soledad. Se convierten en un abstracción fundamental al programar cuando muchas librerías implementan la interface. 

Muchas librerías en Go usan el `Reader` y `Writer` interface. Esto permite abstraer de qué se está leyendo, sin tener en cuenta si es una respuesta http, un buffer o un archivo.

.code src/5interface.go /INTERFACE_S/,/INTERFACE_E/

: No nos vamos a quedar mucho tiempo aca porque esto no es algo que programarian en Go
: es comodo trabajar directo sobre los slices para la mayoria de los casos que implementar metodos para cada caso

## Conceptos de funciones

## Funciones variadicas

.code src/2variadic.go /FUNC_S/,/FUNC_E/

.play -edit src/2variadic.go /PROG_S/,/PROG_E/
.caption Una función puede tomar un número indefinido de argumentos pero la cantidad a devolver es fija 

## Closures (ejemplo)

Escribir:

.play -edit src/2closure.go /PROG_S/,/PROG_E/

Es lo mismo que escribir:

.code src/2closure.go /FPROG_S/,/FPROG_E/
El concepto de un _closure_ solo es útil cuando entran en juego los modificadores de funciones.

: Las funciones son first class citizens en Go. Se pueden usar como variables. Hay veces que tiene sentido pasar una función pero en general el OOP se encarga mejor de eso.
: Los dos ejemplos de arriba son casi idénticos. El compilador de Go usa function inlining por defecto, no asigna un bloque de memoria para cada función
: Este ejemplo es testamento a la inutilidad de closures en un lenguaje común. Se imaginan que concepto de Go las puede hacer útiles?
: Las function modifiers: `go` y `defer`


## Concurrencia

## Un programa no concurrente

.play src/6nonconcurrentcounter.go

: Este es el error típico que cometen todos cuando escriben su primer programa concurrente. Go no espera a que terminen de correr las funciones concurrentes!

## Qué es la concurrencia

* No es paralelismo
* 

Rob Pike, uno de los creadores de Go, dice 

,,_Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once._"



## La palabra clave go

Normalmente, cuando se llama una función el programa se frena hasta que esta termina. Podemos modificar este comportamiento agregando <code>go</code> o la palabra <code>defer</code> antes de la función.

<code>go</code> empieza una "gorutina" ejecutando la función llamada y continua con el programa inmediatamente, sin esperar.

: las gorutinas son super livianas y no es raro tener miles o ciento de miles corriendo a la vez. Las gorutinas no necesariamente son paralelas, en general comparten un procesador esta nota no se si va aca o en un ejemplo mas adelante. despues veremo

<code>defer</code> pospone la llamada hasta el próximo <code>return</code> 

.code  src/6gofirst.go /FUNC_S/,/FUNC_E/

*   Cualquier función puede ser llamada con <code>go</code> o <code>defer</code>

: A diferencia de otros lenguajes como Javascript y Python, cualquier función se puede correr asincrónicamente sin necesidad de modificarla.

## 

.play -edit src/6concurrentcounterpitfall.go
<figcaption>Modificar la segunda llamada a  <code>go Contar("calamares")</code></figcaption>


## Un programa concurrente

.play -edit src/6concurrentcounter.go /MAIN_S/,/MAIN_E/
.caption Si bien el `bool` sirve para sincronizar gorutinas ahora veremos formas más flexibles y poderosas de comunicar *y* sincronizar



## Canales (channels)

## ¿Qué es un canal?

Los canales se usan para mandar mensajes entre gorutinas. 

.code src/6channels.go  /CHAN_S/,/CHAN_E/

.play src/6gopizza.go /MAIN_S/,/FUNC_E/

: Se pueden asignar a variables y pasarse como argumentos a funciones y tienen un tipo asignado.

: Se parecen más a file descriptors

## Select

## Bloqueo de canales lentos

El siguiente programa es limitado por la gorutina más lenta. 0.5 vs. 2 segundos

.play -edit src/6beforeselect.go /MAIN_S/,/MAIN_E/
.caption El programa es limitado por la velocidad a la que el canal 2 puede recibir mensajes (`<-c2`)

## Select

La palabra clave select le permite al programa esperar hasta que haya un canal con un mensaje entre varios canales.

.play -edit src/6afterselect.go /MAIN_S/,/MAIN_E/

## Deadlock

## Contador con canales

.play -edit src/6chancounter.go
.caption Los canales comunican *y* sincronizan. Dos conceptos muy importantes en Go.

: A diferencia del otro código, este si corre la gorutina. La diferencia es que ahora estamos trabajando con canales. Un canal que recibe es Bloqueante hasta que recibe un mensaje, luego pasa control de vuelta a la función

## Deadlock

.play -edit src/6chandeadlock.go

## Deadlock - explicación

La función <code>Contar`</code> termina luego de 5 mensajes. Mientras tanto <code>main</code> se queda esperando un sexto mensaje que nunca llegará! El programa se da cuenta cuando hay un canal bloqueado infinitamente y termina con el error ***deadlock!***.

Para prevenir este error, se puede **cerrar** un canal.

## Cerrando un canal

.play -edit src/6chanclose.go /MAIN_S/,/FUNC_E/
.caption Una vez cerrado el canal el valor de abierto será falso y sabremos que se ha dejado de enviar mensajes por el canal. OJO! Si se manda un mensaje por un canal cerrado el programa termina con error!

## Range canal
El siguiente código hace lo mismo que el anterior pero con menos verbosidad.

.play -edit src/6chanrange.go /MAIN_S/,/FUNC_E/
.caption La palabra clave `range` se puede usar para iterar sobre canales, slices y mapas

## Comunicación entre canales

Mandar por un canal no se compara a un tiro de baloncesto. Es más parecido a una entrega de pizza. La mensajera se queda esperando en la puerta a ser atendida.

.play -edit src/6chanbuffpitfall.go /MAIN_S/,/MAIN_E/
.caption Tanto la mensajera como el receptor pueden causar deadlock. Si no hay gorutinas mensajeras un receptor puede quedarse esperando infinitamente!

En este caso la mensajera bloquea el programa y el receptor nunca llega a atenderlo, causando un ***deadlock***.

Esto se puede resolver usando gorutinas o con *buffered channels*.

## Buffered channels

## Siguiendo la analogía "Delivery de Pizzas"

Si el channel (canal) es la puerta de la casa del receptor, entonces el buffer es una caja donde la mensajera puede dejar la pizza.

.play -edit src/6chanbuff.go /MAIN_S/,/MAIN_E/

Ahora puede seguir la ejecución después de mandar un mensaje. El tamaño del buffer puede ser cualquiera.

¡El mensajero/receptor aún bloqueará si se llena el buffer!


## Paquete os, manejo de errores y lectura de archivos

.play -edit src/5os.go

## Preguntas?