# Go efectivo
Go para entendidos
20 Nov 2020
Tags: curso,avanzado,efectivo
Summary: Desarrollado para un curso de WIE ITBA.
OldURL: https://a/


Patricio Whittingslow
Agustín Canalis
pwhittingslow@itba.edu.ar
acanalis@itba.edu.ar

## First slide
.image ../assets/go-img/gopher.png 200 _
.caption Diseño del _Gopher_ hecho por [[https://instagram.com/reneefrench][Renee French]]
Slide
Slide



## Hola mundo

.play -edit src/1helloworld.go /package/,/MAIN_E/
.caption El %s es un verbo que se le pasa a la función Printf. El siguiente argumento que se le pase a Printf reemplaza el verbo. Una lista completa de verbos [[https://golang.org/pkg/fmt/][aquí]]

.code src/1helloworld.go /FMT_S/,/FMT_E/

## Conceptos de Go

## Zero value

.play -edit src/1zerovalues.go /PROG_S/,/PROG_E/
.caption Los valores de inicialización para tipos numéricos, bools y strings son 0, falso y "" (string vacío), respectivamente

## Terminación de programa

.play -edit src/1termination.go /MAIN_S/,/MAIN_E/

## Structs

## Declaración y asignación

.play -edit src/3structdeclaration.go /package/,/MAIN_E/

## Declaración con new (pointer)

.play -edit src/3structnew.go
.caption Observen que se imprime la struct con el prefijo "`&`". Este es el operador dereferencia. Indica que `p` es un puntero a un datatype. Si no está seguro de la diferencia, no use `new` .

## Declaración composite literal

.code src/3structdeclaration.go /DECL_S/,/DECL_E/

* Se pueden tener campos que sean structs (struct nesting)
* Los campos de una struct puede ser la misma struct. Útil para árboles binarios
* Se puede tener una función en un campo (no es lo mismo que un método)
* Las structs pueden ser comparadas por igualdad con `==`

## Métodos

## Declaración de método y uso

.play -edit src/4method.go /type/,/MAIN_E/

## Método por referencia

La única diferencia de cambiar el receptor a que sea referencia es que se puede modificar los valores de la misma estructura en el mismo método

.play -edit src/4methodref.go /func/,/MAIN_E/
.caption Probar el código con y sin el asterisco en el receptor para ver la diferencia.
## Funciones 2

## Funciones variadicas

.code src/2variadic.go /FUNC_S/,/FUNC_E/

.play -edit src/2variadic.go /PROG_S/,/PROG_E/
.caption Una función puede tomar un número inde90finido de argumentos pero la cantidad a devolver es fija 

## Closures (ejemplo tonto)

.play -edit src/2closure.go /PROG_S/,/PROG_E/

.code src/2closure.go /FPROG_S/,/FPROG_E/

: Las funciones son first class citizens en Go. Se pueden usar como variables. Hay veces que tiene sentido pasar una función pero en general el OOP se encarga mejor de eso.
: Los dos ejemplos de arriba son casi idénticos. El compilador de Go usa function inlining por defecto, no asigna un bloque de memoria para cada función
: Este ejemplo es testamento a la inutilidad de closures en un lenguaje común. Se imaginan que concepto de Go las puede hacer útiles?
: Las function modifiers: `go` y `defer`

## Closure error wrapping

.code src/2closurewrap.go /FUNC_S/,/FUNC_E/ 
.caption El proposito del defer aquí es poder hacerle un posprocesado a los datos una vez que termina la función. En este caso es para generar un error más util para el usuario de la librería/programa.
.play -edit src/2closurewrap.go /PROG_S/,/PROG_E/ 

