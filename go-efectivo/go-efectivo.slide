# Go efectivo
Go para entendidos
20 Nov 2020
Tags: curso,avanzado,efectivo
Summary: Desarrollado para un curso de WIE ITBA.
OldURL: https://a/


Patricio Whittingslow
Agustín Canalis
pwhittingslow@itba.edu.ar
acanalis@itba.edu.ar

## First slide
.image ../assets/go-img/gopher.png 200 _
.caption Diseño del _Gopher_ hecho por [[https://instagram.com/reneefrench][Renee French]]
Slide
Slide



## Hola mundo

.play -edit src/1helloworld.go /package/,/MAIN_E/
.caption El %s es un verbo que se le pasa a la función Printf. El siguiente argumento que se le pase a Printf reemplaza el verbo. Una lista completa de verbos [[https://golang.org/pkg/fmt/][aquí]]

.code src/1helloworld.go /FMT_S/,/FMT_E/

## Conceptos de Go

## Zero value

.play -edit src/1zerovalues.go /PROG_S/,/PROG_E/
.caption Los valores de inicialización para tipos numéricos, bools y strings son 0, falso y "" (string vacío), respectivamente

## Terminación de programa

.play -edit src/1termination.go /MAIN_S/,/MAIN_E/

## Structs

## Declaración y asignación

.play -edit src/3structdeclaration.go /package/,/MAIN_E/

## Declaración con new (pointer)

.play -edit src/3structnew.go
.caption Observen que se imprime la struct con el prefijo "`&`". Este es el operador dereferencia. Indica que `p` es un puntero a un datatype. Si no está seguro de la diferencia, no use `new` .

## Declaración composite literal

.code src/3structdeclaration.go /DECL_S/,/DECL_E/

* Se pueden tener campos que sean structs (struct nesting)
* Los campos de una struct puede ser la misma struct. Útil para árboles binarios
* Se puede tener una función en un campo (no es lo mismo que un método)
* Las structs pueden ser comparadas por igualdad con `==`

## Métodos

## Declaración de método y uso

.play -edit src/4method.go /type/,/MAIN_E/

## Método por referencia

La única diferencia de cambiar el receptor a que sea referencia es que se puede modificar los valores de la misma estructura en el mismo método

.play -edit src/4methodref.go /func/,/MAIN_E/
.caption Probar el código con y sin el asterisco en el receptor para ver la diferencia.

## Implementación de un LIFO stack interface

.play -edit src/5interface.go /type/,/MAIN_E/

: No nos vamos a quedar mucho tiempo aca porque esto no es algo que programarian en Go
: es comodo trabajar directo sobre los slices para la mayoria de los casos que implementar metodos para cada caso



## Funciones 2

## Funciones variadicas

.code src/2variadic.go /FUNC_S/,/FUNC_E/

.play -edit src/2variadic.go /PROG_S/,/PROG_E/
.caption Una función puede tomar un número inde90finido de argumentos pero la cantidad a devolver es fija 

## Closures (ejemplo tonto)

.play -edit src/2closure.go /PROG_S/,/PROG_E/

.code src/2closure.go /FPROG_S/,/FPROG_E/

: Las funciones son first class citizens en Go. Se pueden usar como variables. Hay veces que tiene sentido pasar una función pero en general el OOP se encarga mejor de eso.
: Los dos ejemplos de arriba son casi idénticos. El compilador de Go usa function inlining por defecto, no asigna un bloque de memoria para cada función
: Este ejemplo es testamento a la inutilidad de closures en un lenguaje común. Se imaginan que concepto de Go las puede hacer útiles?
: Las function modifiers: `go` y `defer`

## Closure error wrapping

.code src/2closurewrap.go /FUNC_S/,/FUNC_E/ 
.caption El proposito del defer aquí es poder hacerle un posprocesado a los datos una vez que termina la función. En este caso es para generar un error más util para el usuario de la librería/programa.
.play -edit src/2closurewrap.go /PROG_S/,/PROG_E/ 

## Concurrencia

## Qué es la concurrencia

* No es paralelismo
* 

Rob Pike, uno de los creadores de Go, dice 

,,_Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once._"


## La palabra clave go

**`go`** hace que la función devuelva ejecución a la función circundante inmediatamente

* Funciona para cualquier función

.code  src/6gofirst.go /FUNC_S/,/FUNC_E/

: A diferencia de otros lenguajes como Javascript y Python, cualquier función se puede correr asincrónicamente sin necesidad de modificarla. 
## Mi primer programa concurrente

.play -edit src/6gopitfall.go

.caption  El programa termina inmediatamente después del segundo `Println` durante la ejecución de la primer llamada concurrente

: Este es el error típico que cometen todos cuando escriben su primer programa concurrente. El programa no espera a que termine de correr la primer función llamada

## Mi primer programa concurrente

.play -edit src/6gofirst.go /package/,/MAIN_E/


## Concurrencia

.play -edit src/6goroutine.go 

: `go` es un function modifier, es decir, modifica el comportamiento de la llamada a una función. El único otro function modifier en el lenguaje es `defer` 